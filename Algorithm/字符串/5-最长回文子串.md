# 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

示例 2：

```
输入: "cbbd"
输出: "bb"
```

# 解题思路

## 中心扩展

回文串一定是对称的, 所以我们可以每次选择一个中心, 进行左右扩展, 判断左右字符是否相等即可.

由于存在对称中心是**奇数**或**偶数**的情况, 所有共有$$2N - 1$$个中心, $$N$$是字符串的长度.

这种方法是比较直观的方法, 时间复杂度$$O(N^2)$$, 空间复杂度$$O(1)$$

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 0:
            return ''

        longest_string = s[0]
        longest_start, max_length = 0, 1
        for i in range(n):
            # 以s[i]字符为中心, 向外搜索
            cur_radius = 0
            for j in range(1, n - 1):
                if (i + j) >= n or (i - j) < 0 or s[i + j] != s[i - j]:
                    break
                cur_radius += 1
            t_len = cur_radius * 2 + 1
            if t_len > max_length:
                max_length = t_len
                longest_start = i - cur_radius
            
            # 以s[i-1]s[i]两个字符为中心, 向外搜索
            if (i - 1) >=0 and s[i - 1] == s[i]:
                cur_radius = 0
                for j in range(1, n - 1):
                    if (i + j) >= n or (i - 1 - j) < 0 or s[i + j] != s[i - 1 - j]:
                        break
                    cur_radius += 1
                t_len = cur_radius * 2 + 2
                if t_len > max_length:
                    max_length = t_len
                    longest_start = i - 1 - cur_radius
        longest_string = s[longest_start: longest_start + max_length]
        return longest_string
```

## 动态规划

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 0:
            return ''

        p = [False] * n
        cur_start, cur_length = 0, 1
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, i - 1, -1):
                t = False
                if j - i > 1 and p[j - 1] and s[i] == s[j]:
                    t = True
                elif j - i == 1 and s[i] == s[j]:
                    t = True
                elif j == i:
                    t = True
                elif j < i:
                    break

                p[j] = t
                if t and (j - i + 1) > cur_length:
                    cur_start = i
                    cur_length = j - i + 1
        return s[cur_start: cur_start + cur_length]
```
